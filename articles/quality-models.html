<!DOCTYPE html>
<html lang="en">
<head>
    
    



    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
 
 <!-- SEO includes title and canonical tags, plus several others -->
 <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Quality Models | arc42 Quality Model</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Quality Models" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Since 1976, (scientific) minds have been arguing about a conceptual model around the topic of software product quality. A number of authors proposed different approaches [astrotech.io+2022], until 1991 the ISO organization took over and began publishing its vendor- and product neutral standards ISO-9126. In 2011, that was replaced by the ISO-25010, which is still in active use. Too bad that active use does not correspond to practical or usable… This article presents a few quality models and comes to a (potentially) surprising conclusion… Why do we need a Quality Model Quality consists of many characteristics. Therefore, quality is usually captured in a model or terminology that contains these characteristics and their relationships. Such quality models show what people consider important when talking about quality [Jamwal+2009]. Quality models define a common language for terms related to product, system and software quality. A Bit of History In 1976, [Boehm+1976] published their quality model, including inner qualities like structuredness and legibility. Take a look at the original paper, it is a nice example of historical typesetting, some graphs look like drawn with a ball pen :-). [McCall+1977] suggested to model quality as a hierarchy of terms, whose first level consists of Operation, Revision and Transition. To revision, he counted e.g. Maintainability, Flexibility and Testability. Next [Grady+1992] at Hewlett-Packard published FURPS and its extension FURPS+, the latter found proper acceptance in practice due to its integration into the (once popular) IBM Rational Unified Process [Eeles+2005]. The ISO organization then took up the issue, publishing vendor- and product-neutral standards since 1991, starting with ISO-9126, which “lasted” for 20 years, and was superseded in 2011 by ISO-25010, which is still in effect today. Both were considered the conceptual reference for software quality, and have gained considerable currency in practice. In my humble opinion, this is largely due to the fact that the ISO bodies define the terms used quite properly. Therefore, they can be forgiven for simply ignoring (or forgetting?) some really relevant quality characteristics. I also liked quality features of the VOLERE Requirements Template, which, however, have found less acceptance than the (omnipresent?) ISO model. Quick-Check of Software Quality Models Authors / Name Year Summary Nr of Quality attributes Boehm 1976 Hierarchical model, 3 levels. Top-level qualities: utility, maintainability, portability. See below for more info. 23 McCall 1977 Hierarchical model, 2 levels. Top-level areas: operation, revision, transition. Predecessor of current quality models. 11 ISO-9126 1991 Hierarchical model, 2 levels, 6 top-level qualities. No safety, security underrated, disputable terminology 27 R. Grady, FURPS 1992 Single level with functionality, usability, reliability, performance, supportability. Lacks operational qualities and safety 6 IBM FURPS+ 1999 Add lots of sub-characteristics to FURPS, addressing requirements in general. Part of the (overly complex) Rational-Unified process 30 VOLERE 1999 Integrated in sophisticated template for requirements. Combines qualities and constraints 8 ISO-25010 2011 Supersedes ISO-9126. Hierarchical model with 8 top-level qualities. Adds security as top-level. Widespread, AFAIK. Disputable definitions of terms. 32 Bass et al. 2022 One level, see this article. Practical, with a few rough edges. 10 ISO-25010, draft 2022 2022 Proposal to add safety and change a number of terms and definitions. Still disputable terminology, overly complex for day-to-day use. 39 Boehm Software Quality Model ([Boehm+1976], [Boehm+1978]) Barry Boehm supposedly was the first to propose a hierarchical model of software quality, with three top-level qualities, that are refined on two further levels. When looking into the details of his model, one will notice that several attributes from level-2 and level-3 are referenced multiple times, making this model more of a graph than a tree. In my opinion, this is perfectly realistic, but the later ISO-standards got rid of this pragmatic feature. Please consider this model within the historical perspective: No private person owned a computer, as the personal computer hadn’t been invented. Only very few companies used them, and programming computers was a black art that only a few magicians could apply. With this perspective, the Boehm model was incredibly farsighted, as it included inner quality attributes like legibility and structuredness (which got lost in modern models like ISO) FURPS+ for Classifying Requirements ([Grady+1992], [Eeles+2005]) Robert Grady and Peter Eeles (from Hewlett-Packard) proposed the following schema for classifying requirements: Functionality Usability is concerned with characteristics such as aesthetics and consistency in the user interface. Reliability is concerned with characteristics such as availability (the amount of system “uptime”), accuracy of system calculations, and the system’s ability to recover from failure. Performance is concerned with characteristics such as throughput, response time, recovery time, start-up time, and shutdown time. Supportability is concerned with characteristics such as testability, adaptability, maintainability, compatibility, configurability, installability, scalability, and localizability. The “+” represented several additional categories, such as design-, implementation-, interface- and physical- requirements. [Eeles+2005] Despite the lack of security, safety, resource-consumption and operational qualities, this model was (and likely still is) intensively used in practice. The ISO Standards 9126 and 25010 ([ISO+25010]) Design-by-Committee is regarded as a suboptimal approach to development - and in my opinion that happened to the ISO-standards for software quality. Instead of just unifying definitions from Boehm and FURPS, the invented a kind of metamodel, distinguishing between five different areas of quality (see figure below). Divisions? Model and Management? Measurement and Evaluation? These distinctions seem overly complicated from my practitioners’ viewpoint. I really wonder if anybody working in development projects (except me) ever took the time to read through all those standards. (Ok, I exaggerated, I read only 25010, but that was hard-enough work). Apart from being in wide use, these models really lack practical applicability, although the (still unofficial draft) update from November 2022 somewhat improves the situation). I covered a few downsides in my article on ISO-25010 shortcomings. To summarize: Overly many terms, with a lot of overlap. Critical qualities (e.g. safety, scalability, operational properties) missing from the official version Despite proposing 30+ attributes, code- and architectural qualities are missing No examples of how the ISO-model might be applied to real-world problems But the standards would not have survived as long if they didn’t contain some goodies: The ISO defines all terms contained within the standard, and these definitions are available free-of-charge. Although some of these definitions are quite academic, they provide a nice starting point, and help to avoid conflict when discussing with different stakeholders. SEI Quality Model A quality attribute (QA) is a measurable or testable property of a system that is used to indicate how well the system satisfies the needs of its stakeholders beyond the basic function of the system. You can think of a quality attribute as measuring the “utility” of a product along some dimension of interest to a stakeholder. [Bass+2021, p. 39] For Bass and his colleagues, quality consists of 10 major properties, depicted in the following overview. Wow, what a difference - only 10 areas instead of 40 terms in the ISO 25010 standard. They differentiate these qualities into two categories: We will focus on two categories of quality attributes. The first category includes those attributes that describe some property of the system at runtime, such as availability, performance, or usability. The second category includes those that describe some property of the development of the system, such as modifiability, testability, or deployability. [Bass+2021, p. 42] For their work, a huge “thank you” goes to Len Bass and his colleagues, for providing an alternative to the ISO-25010 approach. They did a great job, and their book is definitely recommended to read in full (please use the fourth edition, as it was heavily updated and modernized!) Now comes my “but”: Their approach can IMHO be further improved. Let me consider the SEI-Model step-by-step: Availability is surely an important goal for many systems, but I know of many systems (or services) that need to work only on certain occasions, and can be turned off the rest of the time. Therefore, I suggest making “reliable” the top-level goal, and availability is part of that. Deployability is great for online- and mobile systems, that are built in highly automated continuous integration workflows. Real-time and embedded systems are (even in 2023) deployed less often, and with less automation. Next thing is, that once the system is deployed, we definitely need to administer, configure and monitor it. Therefore, I suggest making “operable” a top-level quality, and consider “deployable” a sub-goal of that. Energy-efficiency is in many people’s mind, partially due to the incredible increase in energy-consumption by IT infrastructure worldwide. But energy is just one critical resource: What about water, and carbon-dioxide? Again, I prefer a slightly more general term, “resource-efficient”. That even makes “Performance” redundant. Modifiability sounds important, but here again I consider additional aspects: Sometimes I don’t want to modify a system, just install it on another operating system. Or configure a new database for it. In my opinion, the general term is “flexible”. That even allows for removing “Integrability” from the SEI wishlist. arc42 Quality Model Trying to learn from its predecessors (or, as others have called it “it’s easy to stand high on the shoulders of giants”), arc42 proposes a simple, efficient and practical model." />
<meta property="og:description" content="Since 1976, (scientific) minds have been arguing about a conceptual model around the topic of software product quality. A number of authors proposed different approaches [astrotech.io+2022], until 1991 the ISO organization took over and began publishing its vendor- and product neutral standards ISO-9126. In 2011, that was replaced by the ISO-25010, which is still in active use. Too bad that active use does not correspond to practical or usable… This article presents a few quality models and comes to a (potentially) surprising conclusion… Why do we need a Quality Model Quality consists of many characteristics. Therefore, quality is usually captured in a model or terminology that contains these characteristics and their relationships. Such quality models show what people consider important when talking about quality [Jamwal+2009]. Quality models define a common language for terms related to product, system and software quality. A Bit of History In 1976, [Boehm+1976] published their quality model, including inner qualities like structuredness and legibility. Take a look at the original paper, it is a nice example of historical typesetting, some graphs look like drawn with a ball pen :-). [McCall+1977] suggested to model quality as a hierarchy of terms, whose first level consists of Operation, Revision and Transition. To revision, he counted e.g. Maintainability, Flexibility and Testability. Next [Grady+1992] at Hewlett-Packard published FURPS and its extension FURPS+, the latter found proper acceptance in practice due to its integration into the (once popular) IBM Rational Unified Process [Eeles+2005]. The ISO organization then took up the issue, publishing vendor- and product-neutral standards since 1991, starting with ISO-9126, which “lasted” for 20 years, and was superseded in 2011 by ISO-25010, which is still in effect today. Both were considered the conceptual reference for software quality, and have gained considerable currency in practice. In my humble opinion, this is largely due to the fact that the ISO bodies define the terms used quite properly. Therefore, they can be forgiven for simply ignoring (or forgetting?) some really relevant quality characteristics. I also liked quality features of the VOLERE Requirements Template, which, however, have found less acceptance than the (omnipresent?) ISO model. Quick-Check of Software Quality Models Authors / Name Year Summary Nr of Quality attributes Boehm 1976 Hierarchical model, 3 levels. Top-level qualities: utility, maintainability, portability. See below for more info. 23 McCall 1977 Hierarchical model, 2 levels. Top-level areas: operation, revision, transition. Predecessor of current quality models. 11 ISO-9126 1991 Hierarchical model, 2 levels, 6 top-level qualities. No safety, security underrated, disputable terminology 27 R. Grady, FURPS 1992 Single level with functionality, usability, reliability, performance, supportability. Lacks operational qualities and safety 6 IBM FURPS+ 1999 Add lots of sub-characteristics to FURPS, addressing requirements in general. Part of the (overly complex) Rational-Unified process 30 VOLERE 1999 Integrated in sophisticated template for requirements. Combines qualities and constraints 8 ISO-25010 2011 Supersedes ISO-9126. Hierarchical model with 8 top-level qualities. Adds security as top-level. Widespread, AFAIK. Disputable definitions of terms. 32 Bass et al. 2022 One level, see this article. Practical, with a few rough edges. 10 ISO-25010, draft 2022 2022 Proposal to add safety and change a number of terms and definitions. Still disputable terminology, overly complex for day-to-day use. 39 Boehm Software Quality Model ([Boehm+1976], [Boehm+1978]) Barry Boehm supposedly was the first to propose a hierarchical model of software quality, with three top-level qualities, that are refined on two further levels. When looking into the details of his model, one will notice that several attributes from level-2 and level-3 are referenced multiple times, making this model more of a graph than a tree. In my opinion, this is perfectly realistic, but the later ISO-standards got rid of this pragmatic feature. Please consider this model within the historical perspective: No private person owned a computer, as the personal computer hadn’t been invented. Only very few companies used them, and programming computers was a black art that only a few magicians could apply. With this perspective, the Boehm model was incredibly farsighted, as it included inner quality attributes like legibility and structuredness (which got lost in modern models like ISO) FURPS+ for Classifying Requirements ([Grady+1992], [Eeles+2005]) Robert Grady and Peter Eeles (from Hewlett-Packard) proposed the following schema for classifying requirements: Functionality Usability is concerned with characteristics such as aesthetics and consistency in the user interface. Reliability is concerned with characteristics such as availability (the amount of system “uptime”), accuracy of system calculations, and the system’s ability to recover from failure. Performance is concerned with characteristics such as throughput, response time, recovery time, start-up time, and shutdown time. Supportability is concerned with characteristics such as testability, adaptability, maintainability, compatibility, configurability, installability, scalability, and localizability. The “+” represented several additional categories, such as design-, implementation-, interface- and physical- requirements. [Eeles+2005] Despite the lack of security, safety, resource-consumption and operational qualities, this model was (and likely still is) intensively used in practice. The ISO Standards 9126 and 25010 ([ISO+25010]) Design-by-Committee is regarded as a suboptimal approach to development - and in my opinion that happened to the ISO-standards for software quality. Instead of just unifying definitions from Boehm and FURPS, the invented a kind of metamodel, distinguishing between five different areas of quality (see figure below). Divisions? Model and Management? Measurement and Evaluation? These distinctions seem overly complicated from my practitioners’ viewpoint. I really wonder if anybody working in development projects (except me) ever took the time to read through all those standards. (Ok, I exaggerated, I read only 25010, but that was hard-enough work). Apart from being in wide use, these models really lack practical applicability, although the (still unofficial draft) update from November 2022 somewhat improves the situation). I covered a few downsides in my article on ISO-25010 shortcomings. To summarize: Overly many terms, with a lot of overlap. Critical qualities (e.g. safety, scalability, operational properties) missing from the official version Despite proposing 30+ attributes, code- and architectural qualities are missing No examples of how the ISO-model might be applied to real-world problems But the standards would not have survived as long if they didn’t contain some goodies: The ISO defines all terms contained within the standard, and these definitions are available free-of-charge. Although some of these definitions are quite academic, they provide a nice starting point, and help to avoid conflict when discussing with different stakeholders. SEI Quality Model A quality attribute (QA) is a measurable or testable property of a system that is used to indicate how well the system satisfies the needs of its stakeholders beyond the basic function of the system. You can think of a quality attribute as measuring the “utility” of a product along some dimension of interest to a stakeholder. [Bass+2021, p. 39] For Bass and his colleagues, quality consists of 10 major properties, depicted in the following overview. Wow, what a difference - only 10 areas instead of 40 terms in the ISO 25010 standard. They differentiate these qualities into two categories: We will focus on two categories of quality attributes. The first category includes those attributes that describe some property of the system at runtime, such as availability, performance, or usability. The second category includes those that describe some property of the development of the system, such as modifiability, testability, or deployability. [Bass+2021, p. 42] For their work, a huge “thank you” goes to Len Bass and his colleagues, for providing an alternative to the ISO-25010 approach. They did a great job, and their book is definitely recommended to read in full (please use the fourth edition, as it was heavily updated and modernized!) Now comes my “but”: Their approach can IMHO be further improved. Let me consider the SEI-Model step-by-step: Availability is surely an important goal for many systems, but I know of many systems (or services) that need to work only on certain occasions, and can be turned off the rest of the time. Therefore, I suggest making “reliable” the top-level goal, and availability is part of that. Deployability is great for online- and mobile systems, that are built in highly automated continuous integration workflows. Real-time and embedded systems are (even in 2023) deployed less often, and with less automation. Next thing is, that once the system is deployed, we definitely need to administer, configure and monitor it. Therefore, I suggest making “operable” a top-level quality, and consider “deployable” a sub-goal of that. Energy-efficiency is in many people’s mind, partially due to the incredible increase in energy-consumption by IT infrastructure worldwide. But energy is just one critical resource: What about water, and carbon-dioxide? Again, I prefer a slightly more general term, “resource-efficient”. That even makes “Performance” redundant. Modifiability sounds important, but here again I consider additional aspects: Sometimes I don’t want to modify a system, just install it on another operating system. Or configure a new database for it. In my opinion, the general term is “flexible”. That even allows for removing “Integrability” from the SEI wishlist. arc42 Quality Model Trying to learn from its predecessors (or, as others have called it “it’s easy to stand high on the shoulders of giants”), arc42 proposes a simple, efficient and practical model." />
<link rel="canonical" href="https://quality.arc42.org/articles/quality-models" />
<meta property="og:url" content="https://quality.arc42.org/articles/quality-models" />
<meta property="og:site_name" content="arc42 Quality Model" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-07-16T09:12:10+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Quality Models" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-07-16T09:12:10+00:00","datePublished":"2025-07-16T09:12:10+00:00","description":"Since 1976, (scientific) minds have been arguing about a conceptual model around the topic of software product quality. A number of authors proposed different approaches [astrotech.io+2022], until 1991 the ISO organization took over and began publishing its vendor- and product neutral standards ISO-9126. In 2011, that was replaced by the ISO-25010, which is still in active use. Too bad that active use does not correspond to practical or usable… This article presents a few quality models and comes to a (potentially) surprising conclusion… Why do we need a Quality Model Quality consists of many characteristics. Therefore, quality is usually captured in a model or terminology that contains these characteristics and their relationships. Such quality models show what people consider important when talking about quality [Jamwal+2009]. Quality models define a common language for terms related to product, system and software quality. A Bit of History In 1976, [Boehm+1976] published their quality model, including inner qualities like structuredness and legibility. Take a look at the original paper, it is a nice example of historical typesetting, some graphs look like drawn with a ball pen :-). [McCall+1977] suggested to model quality as a hierarchy of terms, whose first level consists of Operation, Revision and Transition. To revision, he counted e.g. Maintainability, Flexibility and Testability. Next [Grady+1992] at Hewlett-Packard published FURPS and its extension FURPS+, the latter found proper acceptance in practice due to its integration into the (once popular) IBM Rational Unified Process [Eeles+2005]. The ISO organization then took up the issue, publishing vendor- and product-neutral standards since 1991, starting with ISO-9126, which “lasted” for 20 years, and was superseded in 2011 by ISO-25010, which is still in effect today. Both were considered the conceptual reference for software quality, and have gained considerable currency in practice. In my humble opinion, this is largely due to the fact that the ISO bodies define the terms used quite properly. Therefore, they can be forgiven for simply ignoring (or forgetting?) some really relevant quality characteristics. I also liked quality features of the VOLERE Requirements Template, which, however, have found less acceptance than the (omnipresent?) ISO model. Quick-Check of Software Quality Models Authors / Name Year Summary Nr of Quality attributes Boehm 1976 Hierarchical model, 3 levels. Top-level qualities: utility, maintainability, portability. See below for more info. 23 McCall 1977 Hierarchical model, 2 levels. Top-level areas: operation, revision, transition. Predecessor of current quality models. 11 ISO-9126 1991 Hierarchical model, 2 levels, 6 top-level qualities. No safety, security underrated, disputable terminology 27 R. Grady, FURPS 1992 Single level with functionality, usability, reliability, performance, supportability. Lacks operational qualities and safety 6 IBM FURPS+ 1999 Add lots of sub-characteristics to FURPS, addressing requirements in general. Part of the (overly complex) Rational-Unified process 30 VOLERE 1999 Integrated in sophisticated template for requirements. Combines qualities and constraints 8 ISO-25010 2011 Supersedes ISO-9126. Hierarchical model with 8 top-level qualities. Adds security as top-level. Widespread, AFAIK. Disputable definitions of terms. 32 Bass et al. 2022 One level, see this article. Practical, with a few rough edges. 10 ISO-25010, draft 2022 2022 Proposal to add safety and change a number of terms and definitions. Still disputable terminology, overly complex for day-to-day use. 39 Boehm Software Quality Model ([Boehm+1976], [Boehm+1978]) Barry Boehm supposedly was the first to propose a hierarchical model of software quality, with three top-level qualities, that are refined on two further levels. When looking into the details of his model, one will notice that several attributes from level-2 and level-3 are referenced multiple times, making this model more of a graph than a tree. In my opinion, this is perfectly realistic, but the later ISO-standards got rid of this pragmatic feature. Please consider this model within the historical perspective: No private person owned a computer, as the personal computer hadn’t been invented. Only very few companies used them, and programming computers was a black art that only a few magicians could apply. With this perspective, the Boehm model was incredibly farsighted, as it included inner quality attributes like legibility and structuredness (which got lost in modern models like ISO) FURPS+ for Classifying Requirements ([Grady+1992], [Eeles+2005]) Robert Grady and Peter Eeles (from Hewlett-Packard) proposed the following schema for classifying requirements: Functionality Usability is concerned with characteristics such as aesthetics and consistency in the user interface. Reliability is concerned with characteristics such as availability (the amount of system “uptime”), accuracy of system calculations, and the system’s ability to recover from failure. Performance is concerned with characteristics such as throughput, response time, recovery time, start-up time, and shutdown time. Supportability is concerned with characteristics such as testability, adaptability, maintainability, compatibility, configurability, installability, scalability, and localizability. The “+” represented several additional categories, such as design-, implementation-, interface- and physical- requirements. [Eeles+2005] Despite the lack of security, safety, resource-consumption and operational qualities, this model was (and likely still is) intensively used in practice. The ISO Standards 9126 and 25010 ([ISO+25010]) Design-by-Committee is regarded as a suboptimal approach to development - and in my opinion that happened to the ISO-standards for software quality. Instead of just unifying definitions from Boehm and FURPS, the invented a kind of metamodel, distinguishing between five different areas of quality (see figure below). Divisions? Model and Management? Measurement and Evaluation? These distinctions seem overly complicated from my practitioners’ viewpoint. I really wonder if anybody working in development projects (except me) ever took the time to read through all those standards. (Ok, I exaggerated, I read only 25010, but that was hard-enough work). Apart from being in wide use, these models really lack practical applicability, although the (still unofficial draft) update from November 2022 somewhat improves the situation). I covered a few downsides in my article on ISO-25010 shortcomings. To summarize: Overly many terms, with a lot of overlap. Critical qualities (e.g. safety, scalability, operational properties) missing from the official version Despite proposing 30+ attributes, code- and architectural qualities are missing No examples of how the ISO-model might be applied to real-world problems But the standards would not have survived as long if they didn’t contain some goodies: The ISO defines all terms contained within the standard, and these definitions are available free-of-charge. Although some of these definitions are quite academic, they provide a nice starting point, and help to avoid conflict when discussing with different stakeholders. SEI Quality Model A quality attribute (QA) is a measurable or testable property of a system that is used to indicate how well the system satisfies the needs of its stakeholders beyond the basic function of the system. You can think of a quality attribute as measuring the “utility” of a product along some dimension of interest to a stakeholder. [Bass+2021, p. 39] For Bass and his colleagues, quality consists of 10 major properties, depicted in the following overview. Wow, what a difference - only 10 areas instead of 40 terms in the ISO 25010 standard. They differentiate these qualities into two categories: We will focus on two categories of quality attributes. The first category includes those attributes that describe some property of the system at runtime, such as availability, performance, or usability. The second category includes those that describe some property of the development of the system, such as modifiability, testability, or deployability. [Bass+2021, p. 42] For their work, a huge “thank you” goes to Len Bass and his colleagues, for providing an alternative to the ISO-25010 approach. They did a great job, and their book is definitely recommended to read in full (please use the fourth edition, as it was heavily updated and modernized!) Now comes my “but”: Their approach can IMHO be further improved. Let me consider the SEI-Model step-by-step: Availability is surely an important goal for many systems, but I know of many systems (or services) that need to work only on certain occasions, and can be turned off the rest of the time. Therefore, I suggest making “reliable” the top-level goal, and availability is part of that. Deployability is great for online- and mobile systems, that are built in highly automated continuous integration workflows. Real-time and embedded systems are (even in 2023) deployed less often, and with less automation. Next thing is, that once the system is deployed, we definitely need to administer, configure and monitor it. Therefore, I suggest making “operable” a top-level quality, and consider “deployable” a sub-goal of that. Energy-efficiency is in many people’s mind, partially due to the incredible increase in energy-consumption by IT infrastructure worldwide. But energy is just one critical resource: What about water, and carbon-dioxide? Again, I prefer a slightly more general term, “resource-efficient”. That even makes “Performance” redundant. Modifiability sounds important, but here again I consider additional aspects: Sometimes I don’t want to modify a system, just install it on another operating system. Or configure a new database for it. In my opinion, the general term is “flexible”. That even allows for removing “Integrability” from the SEI wishlist. arc42 Quality Model Trying to learn from its predecessors (or, as others have called it “it’s easy to stand high on the shoulders of giants”), arc42 proposes a simple, efficient and practical model.","headline":"Quality Models","mainEntityOfPage":{"@type":"WebPage","@id":"https://quality.arc42.org/articles/quality-models"},"url":"https://quality.arc42.org/articles/quality-models"}</script>
<!-- End Jekyll SEO tag -->

    
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<meta name="description" content="  Since 1976, (scientific) minds have been arguing about a conceptual model around the topic of software product quality.A number of authors proposed differe...">
<link rel="shortcut icon" href="/assets/img/arc42logosquare.webp" type="image/x-icon">
    
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
<script>
      try { document.getElementsByTagName('html')[0].className += ' js'; } catch(e) { /* NO-JS */ }
</script>
<link href="/assets/css/style.css" rel="stylesheet">
<script defer data-domain="quality.arc42.org" src="https://plausible.io/js/script.js"></script>






</head>
<body>

<header class="site-header">
    <div class="inner clearfix">
        <button class="fa fa-fw fa-bars nav-toggle" data-target=".site-aside"></button>
        
        <a href="/">
            <img class="avatar" src="/assets/img/arc42logosquare.webp" alt=""/>
        </a>
        
        <h1 class="clearfix">
            <a class="title " href="/">arc42 Quality Model</a>
            
            <br><span class="description"><span style="color:#414288">162</span> quality attributes, explained.</span>
            
            <br><span class="description"><span style="color:#414288">104</span> examples of quality requirements.</span>
        </h1>
    </div>
</header>

<div class="site-container">
    <aside class="site-aside">
        <div class="inner">
            <div class="block">
                <form action="/search">
                    <input type="search" id="search" name="q" placeholder="Search" />
                </form>
            </div>
            <ul>
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                <li><a class="page-link" href="/">Home</a></li>
                
                
                
                <li><a class="page-link" href="/how-to-use-this-site/">How to Use this Site</a></li>
                
                
                
                <li><a class="page-link" href="/qualities/">Qualities by Name</a></li>
                
                
                
                <li><a class="page-link" href="/properties/">Quality Properties</a></li>
                
                
                
                <li><a class="page-link" href="/requirements/">Examples of Quality Requirements</a></li>
                
                
                
                
                
                <li><a class="page-link" href="/q42-for-iso-users/">Q42 for ISO 25010 users</a></li>
                
                
                
                <li><a class="page-link" href="/standards/">Standards</a></li>
                
                
                
                <li><a class="page-link" href="/articles/">Background on "Quality"</a></li>
                
                
                
                <li><a class="page-link" href="/references/">References</a></li>
                
                
                
                <li><a class="page-link" href="/aboutthissite/">About this Site</a></li>
                
                
                
                <li><a class="page-link" href="/contact/">Contact</a></li>
                
                
            </ul>
            <ul class="icons">
                

<li>
    <a href="xmxaxixlxtxo:ixnxfxox@xaxrxcx4x2x.xdxe" onmouseover="this.href=this.href.replace(/x/g,'');">
        <i class="fa fa-fw fa-envelope" aria-hidden="true"></i>
    </a>
</li>

<li><a href="https://linkedin.com/in/gernotstarke">
      <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i>
    </a>
</li>



<li>
    <a href="https://github.com/arc42" target="_blank">
        <i class="fab fa-fw fa-github" aria-hidden="true"></i>
    </a>
</li>





<li>
    <a href="https://stackoverflow.com/tags/arc42" target="_blank">
        <i class="fab fa-fw fa-stack-overflow" aria-hidden="true"></i>
    </a>
</li>




<li>
    <a href="https://youtube.com/arc42-video" target="_blank">
        <i class="fab fa-fw fa-youtube" aria-hidden="true"></i>
    </a>
</li>



<li><a href="https://dev.to/gernotstarke/" target="_blank">
  <i class="fab fa-dev" aria-hidden="true"></i> </a>
</li>


<li><a href="https://www.innoq.com/de/staff/gernot-starke/" target="_blank">
  <i class="fas fa-heart fa-fw" style="color:#ff9c66;"></i> </a>
</li>




            </ul>
            <hr class="with-no-margin margin-bottom"/>
            <a href="https://github.com/arc42/quality.arc42.org-site/issues">
               <img alt="GitHub issues" src="https://img.shields.io/github/issues-raw/arc42/quality.arc42.org-site?style=social">
               <img alt="GitHub closed issues" src="https://img.shields.io/github/issues-closed-raw/arc42/quality.arc42.org-site?style=social">
            </a>
            <hr class="with-no-margin margin-bottom"/>
        </div>
    </aside>

    <div class="site-content">
        <div class="article-wrapper">
    <article>
        

<header>
    <div class="panel">
        <h1>
            
            Quality Models
            
        </h1>

        <ul class="tags">
            
            
            
        </ul>

        <div class="clearfix">
            <ul class="meta">
                
                
            </ul>
        </div>
    </div>


</header>

        <section class="post-content">
            <div class="arc42-help">
  <p>Since 1976, (scientific) minds have been arguing about a conceptual model around the topic of <em>software product quality</em>.
A number of authors proposed different approaches [<a href="https://dev.astrotech.io/sonarqube/quality-models.html">astrotech.io+2022</a>], until 1991 the ISO organization took over and began publishing its vendor- and product neutral standards ISO-9126.
In 2011, that was replaced by the ISO-25010, which is still in active use.</p>

  <p>Too bad that <em>active use</em> does <strong>not</strong> correspond to practical or usable…</p>

  <p>This article presents a few quality models and comes to a (potentially) surprising conclusion…</p>

</div>
<p><br /></p>

<h3 id="why-do-we-need-a-quality-model">Why do we need a Quality Model</h3>
<p>Quality consists of many characteristics. 
Therefore, quality is usually captured in a model or terminology that contains these
characteristics and their relationships. 
Such quality models show what people consider important when talking about quality <a href="/references/#jamwal">[Jamwal+2009]</a>.</p>

<p>Quality models define a <em>common language</em> for terms related to product, system and software quality.</p>

<h3 id="a-bit-of-history">A Bit of History</h3>

<p>In 1976, <a href="/references/#boehm1976quantitative">[Boehm+1976]</a> published their quality model, including inner qualities like <em>structuredness</em> and <em>legibility</em>. Take a look at the original paper, it is a nice example of <em>historical typesetting</em>, some graphs look like drawn with a ball pen :-).</p>

<p><a name="mccall"></a><a href="/references/#mccall1977factors">[McCall+1977]</a> suggested to model quality as a hierarchy of terms, whose first level consists of <em>Operation, Revision</em> and <em>Transition</em>. To revision, he counted e.g. Maintainability, Flexibility and Testability.</p>

<p>Next <a href="/references/#grady1992practical">[Grady+1992]</a> at Hewlett-Packard published FURPS and its extension FURPS+, the latter found proper acceptance in practice due to its integration into the (once popular) IBM Rational Unified Process <a href="/references/#eeles2005capturing">[Eeles+2005]</a>.</p>

<p>The ISO organization then took up the issue, publishing vendor- and product-neutral standards since 1991, starting with ISO-9126, which “lasted” for 20 years, and was superseded in 2011 by ISO-25010, which is still in effect today. 
Both were considered the conceptual reference for software quality, and have gained considerable currency in practice. 
In my humble opinion, this is largely due to the fact that the ISO bodies define the terms used quite properly. 
Therefore, they can be forgiven for simply ignoring (or forgetting?) some really relevant quality characteristics.
I also liked quality features of the <a href="/references/#volere">VOLERE Requirements Template</a>, which, however, have found less acceptance than the (omnipresent?) ISO model.</p>

<h3 id="quick-check-of-software-quality-models">Quick-Check of Software Quality Models</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Authors / Name</th>
      <th style="text-align: right">Year</th>
      <th style="text-align: left">Summary</th>
      <th style="text-align: left">Nr of Quality attributes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><a href="#boehm">Boehm</a></td>
      <td style="text-align: right">1976</td>
      <td style="text-align: left">Hierarchical model, 3 levels. Top-level qualities: <em>utility, maintainability, portability</em>. See below for more info.</td>
      <td style="text-align: left">23</td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="#mccall">McCall</a></td>
      <td style="text-align: right">1977</td>
      <td style="text-align: left">Hierarchical model, 2 levels. Top-level areas: <em>operation</em>, <em>revision</em>, <em>transition</em>. Predecessor of current quality models.</td>
      <td style="text-align: left">11</td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="#iso">ISO-9126</a></td>
      <td style="text-align: right">1991</td>
      <td style="text-align: left">Hierarchical model, 2 levels, 6 top-level qualities. No safety, security underrated, disputable terminology</td>
      <td style="text-align: left">27</td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="#eeles">R. Grady, FURPS</a></td>
      <td style="text-align: right">1992</td>
      <td style="text-align: left">Single level with <em>functionality, usability, reliability, performance, supportability</em>. Lacks operational qualities and safety</td>
      <td style="text-align: left">6</td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="#eeles">IBM FURPS+</a></td>
      <td style="text-align: right">1999</td>
      <td style="text-align: left">Add lots of sub-characteristics to FURPS, addressing <em>requirements</em> in general. Part of the (overly complex) Rational-Unified process</td>
      <td style="text-align: left">30</td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="/references/#volere">VOLERE</a></td>
      <td style="text-align: right">1999</td>
      <td style="text-align: left">Integrated in sophisticated template for requirements. Combines qualities and constraints</td>
      <td style="text-align: left">8</td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="#iso">ISO-25010</a></td>
      <td style="text-align: right">2011</td>
      <td style="text-align: left">Supersedes ISO-9126. Hierarchical model with 8 top-level qualities. Adds security as top-level. Widespread, AFAIK. Disputable definitions of terms.</td>
      <td style="text-align: left">32</td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="#sei">Bass et al.</a></td>
      <td style="text-align: right">2022</td>
      <td style="text-align: left">One level, see <a href="/articles/sei-quality-model">this article</a>. Practical, with a few rough edges.</td>
      <td style="text-align: left">10</td>
    </tr>
    <tr>
      <td style="text-align: left"><a href="/references/#iso-25010-2022">ISO-25010, draft 2022</a></td>
      <td style="text-align: right">2022</td>
      <td style="text-align: left">Proposal to add safety and change a number of terms and definitions. Still <a href="/articles/iso-25010-shortcomings">disputable terminology</a>, overly complex for day-to-day use.</td>
      <td style="text-align: left">39</td>
    </tr>
  </tbody>
</table>

<h3 id="boehm-software-quality-model-boehm1976-boehm1978">Boehm Software Quality Model (<a href="/references/#boehm1976quantitative">[Boehm+1976]</a>, <a href="/references/#boehm1978characteristics">[Boehm+1978]</a>)</h3>
<p><a name="boehm"></a>
Barry Boehm supposedly was the first to propose a hierarchical model of software quality, with three top-level qualities, that are refined on two further levels. 
When looking into the details of his model, one will notice that several attributes from level-2 and level-3 are referenced multiple times, making this model more of a graph than a tree.
In my opinion, this is perfectly realistic, but the later ISO-standards got rid of this pragmatic feature.</p>

<p><img src="/images/articles/quality-models/Boehm-Quality-Model.svg" alt="Boehm Quality Model" /></p>

<p>Please consider this model within the historical perspective: No private person owned a computer, as the personal computer hadn’t been invented.
Only very few companies used them, and programming computers was a black art that only a few <em>magicians</em> could apply.</p>

<p>With this perspective, the Boehm model was incredibly farsighted, as it included inner quality attributes like <em>legibility</em> and <em>structuredness</em> (which got lost in modern models like ISO)</p>

<h3 id="furps-for-classifying-requirements-grady1992-eeles2005">FURPS+ for Classifying Requirements (<a href="/references/#grady1992practical">[Grady+1992]</a>, <a href="/references/#eeles2005capturing">[Eeles+2005]</a>)</h3>
<p><a name="eeles"></a>
Robert Grady and Peter Eeles (from Hewlett-Packard) proposed the following schema for classifying requirements:</p>

<blockquote>
  <ul>
    <li><em>Functionality</em></li>
    <li><em>Usability</em> is concerned with characteristics such as aesthetics and consistency in the user interface.</li>
    <li><em>Reliability</em> is concerned with characteristics such as availability (the amount of system “uptime”), accuracy of system calculations, and the system’s ability to recover from failure.</li>
    <li><em>Performance</em> is concerned with characteristics such as throughput, response time, recovery time, start-up time, and shutdown time.</li>
    <li><em>Supportability</em> is concerned with characteristics such as testability, adaptability, maintainability, compatibility, configurability, installability, scalability, and localizability.</li>
  </ul>

  <p>The “+” represented several additional categories, such as design-, implementation-, interface- and physical- requirements.</p>

  <p><a href="/references/#eeles2005capturing">[Eeles+2005]</a></p>
</blockquote>

<p>Despite the lack of security, safety, resource-consumption and operational qualities, this model was (and likely still is) intensively used in practice.</p>

<h3 id="the-iso-standards-9126-and-25010-iso25010">The ISO Standards 9126 and 25010 (<a href="/references/#iso-25010-2011">[ISO+25010]</a>)</h3>
<p><a name="iso"></a>
<em>Design-by-Committee</em> is regarded as a <em>suboptimal approach to development</em> - and in my opinion that happened to the ISO-standards for software quality.
Instead of just unifying definitions from Boehm and FURPS, the invented a kind of metamodel, distinguishing between five different areas of quality (see figure below).
Divisions? Model and Management? Measurement and Evaluation? 
These distinctions seem overly complicated from my practitioners’ viewpoint.</p>

<p><img src="/images/articles/quality-models/ISO-25-Meta-Structure.svg" alt="Areas of quality as defined by ISO" /></p>

<p>I really wonder if anybody working in development projects (except me) ever took the time to read through all those standards. (Ok, I exaggerated, I read only 25010, but that was hard-enough work).</p>

<p>Apart from being in wide use, these models really lack practical applicability, although the (still unofficial draft) update from November 2022 somewhat improves the situation).
I covered a few downsides in my <a href="/articles/iso-25010-shortcomings">article on ISO-25010 shortcomings</a>.
To summarize:</p>

<ul>
  <li>Overly many terms, with a lot of overlap.</li>
  <li>Critical qualities (e.g. safety, scalability, operational properties) missing from the official version</li>
  <li>Despite proposing 30+ attributes, code- and architectural qualities are missing</li>
  <li>No examples of how the ISO-model might be applied to real-world problems</li>
</ul>

<p>But the standards would not have survived as long if they didn’t contain some goodies:
The ISO defines all terms contained within the standard, and <em>these</em> definitions are available free-of-charge.
Although some of these definitions are quite academic, they provide a nice starting point, and help to avoid conflict when discussing with different stakeholders.</p>

<h3 id="sei-quality-model">SEI Quality Model</h3>
<p><a name="sei"></a></p>
<blockquote>
  <p>A quality attribute (QA) is a measurable or testable property of a system that is used to indicate how well the system satisfies the needs of its stakeholders beyond the basic function of the system. 
You can think of a quality attribute as measuring the “utility” of a product along some dimension of interest to a stakeholder.</p>

  <p><a href="/references/#bass2021software">[Bass+2021, p. 39]</a></p>
</blockquote>

<p>For Bass and his colleagues, quality consists of 10 major properties, depicted in the following overview.</p>

<p><img src="/images/articles/sei-2022/sei-quality-model-v2022.png" alt="10-top level quality attributes from SEI" /></p>

<p>Wow, what a difference - only 10 <em>areas</em> instead of 40 terms in the ISO 25010 standard.
They differentiate these qualities into two categories:</p>

<blockquote>
  <p>We will focus on two categories of quality attributes. The first category includes those attributes that describe some property of the system at runtime, such as availability, performance, or usability. 
The second category includes those that describe some property of the development of the system, such as modifiability, testability, or deployability.</p>

  <p><a href="/references/#bass2021software">[Bass+2021, p. 42]</a></p>
</blockquote>

<p>For their work, a huge “thank you” goes to Len Bass and his colleagues, for providing an alternative to the ISO-25010 approach. 
They did a great job, and their book is definitely recommended to read in full (please use the fourth edition, as it was heavily updated and modernized!)</p>

<p>Now comes my “but”: Their approach can IMHO be further improved. 
Let me consider the SEI-Model step-by-step:</p>

<ul>
  <li><em>Availability</em> is surely an important goal for many systems, but I know of many systems (or services) that need to work only on certain occasions, and can be turned off the rest of the time. Therefore, I suggest making “reliable” the top-level goal, and availability is part of that.</li>
  <li><em>Deployability</em> is great for online- and mobile systems, that are built in highly automated continuous integration workflows. Real-time and embedded systems are (even in 2023) deployed less often, and with less automation. Next thing is, that once the system is deployed, we definitely need to administer, configure and monitor it. Therefore, I suggest making “operable” a top-level quality, and consider “deployable” a sub-goal of that.</li>
  <li><em>Energy-efficiency</em> is in many people’s mind, partially due to the incredible increase in energy-consumption by IT infrastructure worldwide. But energy is just one critical resource: What about water, and carbon-dioxide? Again, I prefer a slightly more general term, “resource-efficient”. That even makes “Performance” redundant.</li>
  <li><em>Modifiability</em> sounds important, but here again I consider additional aspects: Sometimes I don’t want to modify a system, just install it on another operating system. Or configure a new database for it. In my opinion, the general term is “flexible”. That even allows for removing “Integrability” from the SEI wishlist.</li>
</ul>

<h3 id="arc42-quality-model">arc42 Quality Model</h3>
<p>Trying to learn from its predecessors (or, as others have called it “it’s easy to stand high on the shoulders of giants”), arc42 proposes a simple, efficient and practical model.</p>

        </section>
        <footer>
    
</footer>

    </article>
</div>



    </div>
</div>

<footer class="site-footer">
    <div class="inner">
        <p class="footer-icons"><a href="https://www.innoq.com" target="_blank" rel="noopener noreferrer nofollow"><img class="supported-by-innoq" src="/images/supported-by-innoq--petrol-apricot.svg"></a><br>
            <a href="https://status.arc42.org">
                <i class="fa fa-chart-bar fa-fw" style="color:#50C878;" ></i>Status</a><i>&nbsp;&nbsp;</i>
            <i class="fa fa-user-secret" aria-hidden="true"></i>
            <a href="/imprint">
                Imprint + Privacy</a></p>
        <span>Maintained by <a target="_blank" rel="noopener noreferrer nofollow" href="https://gernotstarke.de">Gernot Starke</a>,
          supported by <a target="_blank" rel="noopener noreferrer nofollow" href="https://perstarke-webdev.de">Per Starke Web Development</a>
        </span>
    </div>
</footer>


<script src="/assets/jquery/jquery-3.7.1-min.js"></script>
<script src="/assets/lib/garand-sticky/jquery.sticky.js"></script>
<script src="/assets/js/script.js"></script>


<script src="/assets/js/header-link.js"></script>





</body>
</html>
